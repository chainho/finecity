About Concurrency

如果没有**阻塞**，那么在单处理器机器上并发就没有任何意义。**但阻塞如果出现在顺序执行的，会导致整个程序阻塞**，而并发不会。

* Erlang是函数式语言，专门针对并发。
* 协作多线程
* 基于消息机制的架构

使用线程是一种建立透明的、可扩展程序的方法。
**后台线程**的`finally`子句不保证一定会执行，当所有主线程退出，所有后台线程会立即停止。
捕获异常的方式：可以为每个线程指定一个异常处理器，用于处理未捕获的异常，类似：
```
Thread.uncaughtException
Thread.setDefaultUncaughtException
```

当要执行`synchronized`保护的代码时，先检查**锁**是否可用，然后获取锁，执行代码。使用`synchronized`，当失败时抛出异常，而显式的锁可以用来作些清理工作。

当类中只有一个可变域时可以使用一个`volatile`，否则使用`synchronized`。

当临界区(同步块)中的锁是**不同对象**时，可以多个方同时运行,如果使用同一个锁`this`，则只能有一个方法运行。

同步只是对象的不完全锁，如果其他线程不需要对此对象同步，他们可以使用该同步对象的。
>它只能防止**对同一对象同步**的其它线程使用共享资源。


-----------------

收集同步需求
线程产生死锁的原理模拟
把每个线程假想为有向图中的一个节点，图中每条边表示的关系是**线程A等待线程B所占有的资源，在图中如果形成了一条环路，那么就存在 一个死锁**。
死锁检测：在表示等待关系的有向图中搜索**循环**。

tips:
* 线程转储中包含许多有用的信息，包含死锁等。
* JVM 会自动在有向图中搜索检查
* 

活跃性问题：死锁、活锁、饥饿、丢失信号、其它。

当多个相互协作的线程都对彼此进行响应，从而修改各自的状态，并使得任何一个线程都无法继续执行，就发生了活锁。(要解决该问题，需要在重试机制中引入随机性，即重试的时机不能一样)


以测试为基准，不要猜测，使用性能分析工具找出瓶颈(Perf bar)

Amdahl定律

    speedup <= 1 / (F + (1-F)/N)
    
    其中F为必须被串行执行的部分，N为处理器个数
    
    
降低锁竞争的方式：
* 减少锁的持有时间  (缩小代码块同步，减小锁的粒度，由对象锁改为各个容器的锁)
* 降低锁的请求频率
* 使用带有协调机制的独占锁

内置的JMX代理提供了一系列监测行为，在ThreadInfo类中包含...，如果启用了"线程竞争监测"功能，还包含被阻塞的次数，等待时间等。

读写锁：
一个资源可以被多个读操作访问，或者被一个写操作的访问，但两者不能同时进行。


> 资源排序避免死锁

ThreadLocal如何理解？维护一个变量的本地副本？如何更新回主内存？


###Java虚拟机并发编程 (STM & Actors)

####第一部分  并发策略


* 分工原则(IO密集型与计算密集型)
* 设计方法
    * 处理状态
    * 共享可变性
    * 隔离可变性
    * 纯粹不可变对象
    * 不可变数据结构

####第二部分 现代JDK并发模型


* 可扩展性与线程安全
* 驯服共享可变性
    * 从一个变量可被多个线程读写，则是可访问且共享的。如果仅能被一个线程访问，则其为隔离非共享的。
    * 可见性：如果不强制访问变量时一定要穿越内存栅栏,线程无法及时看到值的变化。
    * 创建线程池时，可以通过`ThreadFactory`设置其具体属性为非守护线程等
    * 让线程在合适的时间跨越内存栅栏很重要，可以保证**竞争**与**可见性**。
    * 增强并发性，将代码中的`synchronized`进行有选择的替换，使粒度控制的更细。
    * 使用`ReentrantReadWriteLock`区分读写锁，保证操作的原子性与性能，保证不会使其它线程看到部分修改的结果。




